# Лабораторная работа \# 4

### Введение

В этой лабораторной работе фронтэнд и бэкэнд практически не зависят друг от друга, 
т.к. взаимодействие с ними происходит посредством REST API.  
Как это работает?  
Уровень back-end, условно говоря, предоставляет несколько url'ов при обращении на которые он будет возвращать некоторый результат(например, запрос 'GET localhost:8080/api/users', предположим,
 будет возвращать список всех пользователей). Поэтому front-end разработчику нужно будет знать только запросы, которые надо делать к нашему API, и их результат. Соответсвенно, front-end, как и back-end могут быть написаны на чём угодно, более того, front-end может быть, например, десктопным или мобильным приложением, а не только веб-приложением.  

### Аутентификация

Существует несколько различных способов аутентификации пользователей, но я рассмотрю только два из них.  
Так как у нас REST API является stateless(то есть, не хранит состояние), нам придётся с каждым запросом, который доступен только аутентифицированным пользователям, отпавлять что-то, 
что поможет понять back-end'у, что запрос пришёл от пользователя, прошедего аутентификацию.

###### Аутентификация по паролю(basic)

Этот вид аутентификации предполагает, что после ввода своего логина и пароля, клиент хранит их у себя до выхода из системы, и при каждом запросе, требующем аутентификации, отправляет их вместе с запросом.  
Обычно это делается так:  
1. Клиентское приложение формирует строку из данных пользователя в формате 'логин:пароль'
1. Потом клиент кодирует эту строку, например, при помощи Base64. Пусть результат кодирование будет выглядеть так: 'bG9naW46cGFzc3dvcmQ='. (Внимание! Кодирование не означает шифрование или хэширование - эту строку при получении можно будет легко декодировать обычным Base64 декодером)
1. Клиент добавляет к запросу, который требует аутентификацию, новый header с именем Authorization и значением 'Basic bG9naW46cGFzc3dvcmQ='.
1. Отправка запроса на back-end. Если запрос прошёл аутентификацию, то наш бэк вернёт нормальный ответ, если нет - сообщение об ошибке 401 или 403.  

Хочу отметить, что если у вас back-end на spring, то от вас ничего не потребудется делать, для реализации этого вида аутентификации - spring практически всё будет делать за вас.

###### Аутентификация по токену(bearer)

При этом способе аутентификации логин и пароль придётся отправить всего один раз за сеанс - только при входе в аккаунт.
После успешной аутентификации back-end должен отправить нам токен(токен в самом простом случае, это просто рандомная строка, которая генерируется для клиента при входе в аккаунт),
а клиент должен этот токен у себя сохранить.
Тогда запросы требующие аутентификации будут проходить так:  
1. Клиент достаёт у себя из хранилища, полученный когда-то токен, пусть он равен 'SGVsbG8gZnJvbSAyMDE5IQ==', и добавляет к запросу, который требует аутентификацию,
header с именем Authorization и значением 'Bearer SGVsbG8gZnJvbSAyMDE5IQ=='.
1. Отправка запроса на back-end. Если запрос прошёл аутентификацию, то наш бэк вернёт нормальный ответ, если нет - сообщение об ошибке 401 или 403.  

Этот способ сложнее для реализации на spring'e, т.к. тут уже придётся делать некоторые неочевидные на первый взгляд вещи.
Однако на Java EE хоть и придётся вручную делать оба вышеперечисленных способа аутентификации, но как мне показалось, делается это более очевидно, чем в spring.


### Разворачивание лабы

При разработке, конечно, удобнее когда back-end и front-end размещены на разных серверах и могут модифицироваться отдельно. Также это удобнее, потому что, если вы, например, используется на сервере front-end'a для сборки webpack и делаете какие-либо изменения в исходниках фронта, то вам не придётся каждый раз перезапускать сервер - webpack сам очень быстро пересоберёт изменённые модули.  
Пока я рассмотрю только случай на Spring без использования стороннего сервера приложений, т.к., например, Spring boot уже содержит встроенный сервер.

1. Первым делом вам надо сбилдить проект front-end'a делается это обычно при помощи команд следующих команд:
```shell
ng build
npm build
npm run-script build
```
1. Наш собранный front-end должен оказаться в директории dist, располагающейся в корне проекта. Оттуда его надо закинуть в src/main/resources/static в проекте back-end'a.
1. Собрать jar архив. Если вы пользовались Spring Initializr для генерации проекта, то там уже будут настроенные системы автоматической сборки, и тогда собрать это можно будет так:
```shell
\# gradle
./gradlew bootJar
\# maven
./mvnw clean package
```
1. Запустить как обычный jar архив:
```shell
java -jar lab4.jar
```

####### Замечание
Убедитесь, что Spring Security не будет блокировать запросы на получение статического контента и что над классом конфигурации НЕ стоит аннотация @EnableWebMvc.
Так как у нас фронтенд приложение является SPA(Singe Page Application), то нам придётся объяснить бэку, что при запросах на url'ы, которые соответсвует какому-либо компоненту SPA, надо отдавать наш 
единственный index.html, а не пытаться найти какую-то другую страницу. Пример реализации этого можно посмотреть [a здесь](https://github.com/DeltaThreeEight/Spring-Backend-for-Lab4/blob/master/src/main/java/app/controller/FrontController.java).



